~~LANG:EN@enman:using_classes~~

Pour respecter le modèle en couche, il est recommandé de réaliser tous ses traitements métiers et services dans des classes dédiées.

Dans de telles classes, vous manipulerez par exemple des daos, des données issues de daos ou autre, effectuerez donc des traitements autres que de l'affichage. Aussi les méthodes de vos contrôleurs s'en trouveront allégées et les traitements réutilisables dans d'autres actions.

===== Création d'une classe =====

Les classes métiers et services dans Jelix sont des classes PHP classiques qui n'ont rien de spécifique. La seule chose à respecter est de les stocker dans un fichier nom_de_la_classe.class.php dans le répertoire classes du module :

<code php>  
   class StockService {
      public function getListeProduits(){
          $stock = jDAO::get("products");
          
          $liste = $stock->findAll();
          
          // ici traitement sur la liste... par exemple
          
          
          return $liste;      
      }
   }
</code>

Cette classe devra être stockée dans classes/StockService.class.php.


La différence entre une classe service et les autres classes est qu'une classe service fournit, comme son nom l'indique, un service. Elle n'a pas besoin d'être instanciée à chaque utilisation car elle ne possède pas de propriétés "discriminantes". Une seule instance suffit pour toute l'application.

Par exemple une classe de type "factory", qui permet de récupérer des ensembles de données, est une classe service. Par contre une classe représentant un produit, qui possède donc des champs identifiants, est une classe non service.
===== Inclure des classes ou des interfaces définies dans un module =====

@@C@jClasses@@ fournit les méthodes static @@M@inc()@@ et @@M@incIFace@@ pour inclure des classes définies dans le dossier @@F@classes@@ d'un module.

Une classe doit être définie avec la syntaxe PHP (mot clé class) dans un fichier à son nom suivi du suffixe .class.php. Pour déclarer la classe StockUtil par exemple, il faut créer un fichier StockUtil.class.php et y mettre le code suivant :
<code php><?php
class StockUtil {
    […]
}
?></code>

Une interface doit-elle être définie avec la syntaxe PHP (mot clé interface) dans un fichier à son nom suivi du suffixe .iface.php. Pour filer l'exemple précédent, on peut déclarer l'interface IStockUtil dans un fichier IStockUtil.iface.php dans un sous dossier interfaces du dossier classes :
<code php><?php
interface ISctockUtil {
    […]
}
?></code>

Pour inclure la classe StockUtil définie dans le module commons, il convient d'utiliser en en-tête du fichier où on l'utiliser la syntaxe suivante :
<code php><?php
jClasses::inc('commons~StockUtil');

[…]
?></code>

Pour une interface, on utilisera cette syntaxe :
<code php><?php
jClasses::inIface('commons~interfaces/IStockUtil');

class StockUtil implements IStockUtil {
    […]
}
?></code>

===== Instanciation =====

Jelix propose la classe jClasses, qui vous évite d'avoir à faire un include et une instanciation par vous même.

jClasses fournit deux méthodes statiques, auxquelles vous indiquez un sélecteur :

    * createInstance($selecteurDeClasse); (ou create($selecteurDeClasse) )
    * getService($selecteurDeClasse);


La première créera à chaque appel une nouvelle instance. Par contre la deuxième renverra toujours une même instance de la classe. getService sera donc utilisé sur les classes services, et createInstance sur les autres.

Si notre classe StockService se trouve dans le module "shop", voici un exemple d'appel dans un contrôleur:

<code php>
    $stocksrv = jClasses::getService("shop~stockservice");
    $rep->body->assign('liste_produits', $stocksrv->getListeProduits());
</code>

Cependant dans certains cas, comme celui où le constructeur de la classe métier demande un paramètre, il faut inclure la classe métier puis l'instancier "manuellement".

Dans ce cas la classe jClasses propose la méthode statique inc($selecteurDeClasse). Comme son nom l'indique elle inclut (en fait effectue un require_once) la classe spécifiée par le sélecteur.

Exemple :
<code php>
    jClasses::inc('shop~shoesProduct');
    $shoe = new shoesProduct('43', 'black');
</code>


Notez que vous pouvez mettre des classes dans des sous-répertoires de "classes/", ce qui donne, si on place StockService dans un répertoire classes/stocks/ :

<code php>
   $stocksrv = jClasses::getService("shop~stocks/stockservice");
</code>


===== Installer et Utiliser des classes tierces =====

Il se peut que vous vouliez réutiliser des classes développées en dehors du projet. Il est bien entendu tout à fait possible de le faire dans Jelix.

Bien que vous puissiez mettre ces classes où bon vous semble et faire un include classique, il y a toutefois deux emplacements préconisés :

  * le répertoire lib
  * le répertoire classes d'un module

Faire un répertoire spécifique dans lib/ et y placer les fichiers de classes, est intéressant  quand il s'agit de partager ces classes entre plusieurs modules, voir entre plusieurs projets. Pour faire les includes, vous pouvez utiliser la constante LIB_PATH. Par exemple si vous voulez inclure une classe que vous avez dans lib/foo/bar.php, vous ferez alors ceci :

<code php>
   require(LIB_PATH.'foo/bar.php');
   $maclasse = new bar();
</code>

Placer les classes tierces dans le répertoire classes est utile si les classes en question ne sont utilisées que par ce module. Cela permet aussi une réutilisation plus facile : tout est dans le module.

Pour utiliser ces classes, en admettant que vous voulez inclure le fichier bar.php que vous avez placé dans le répertoire classes du module main, vous pouvez faire :

<code php>
   require(JELIX_APP_PATH.'modules/main/classes/bar.php');
   $maclasse = new bar();
</code>

Si le nom du fichier de la classe respecte la norme des fichiers de classes pour jelix (bar.class.php), et que la classe s'appelle effectivement "bar", vous pouvez bien entendu utiliser jClasses :

<code php>
   $maclasse = jClasses::create('bar');

   // ou si le constructeur attend des arguments
   jClasses::inc('bar');
   $maclasse = new bar('bla');

</code>


===== Charger des classes avant le session_start =====

Parfois, vous voulez stockez en session des objets basés sur vos classes métiers. Mais pour cela, il faut inclure ces classes avant que jelix fasse un @@f@session_start()@@, pour que PHP puisse désérialiser correctement l'objet en session.

Jelix fournit un moyen simple d'indiquer les classes à charger avant ce @@f@start_session()@@ : il suffit d'indiquer la liste des sélecteurs de ces classes dans l'option @@V@loadClasses@@ de la section @@sessions@@ dans la configuration :

<code ini>
[sessions]

loadClasses = "mymodule~bar,mymodule~subdir/foo, shop~shoesProduct"
</code>


Note: le nom du module est obligatoire.

===== Autoload =====

Description:

Le système d'autoload supporte la [[https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md|spécification PSR0]]

module.xml:

L'autoload peut à présent être défini dans le fichier module.xml de vos modules, pour charger les classes dont vous avez besoin
The autoload can now be defined into the module.xml file of your modules, to automatically load classes for your own needs.

Votre  @@F@module.xml@@ ressemblerait à présent à ceci :

<code xml>
<module xmlns="http://jelix.org/ns/module/1.0">
    <info id="jelix_tests@testapp.jelix.org" name="jelix_tests">
        <version>1.0</version>
        <label>Jelix tests</label>
        <description>unit tests for jelix</description>
    </info>
    <dependencies>
        <jelix minversion="1.4" maxversion="1.4.*" />
        <module name="testurls" minversion="1.0.2" maxversion="1.1b1" />
        <module name="jauthdb" />
        <module name="jacl2db" />
        <module name="jacldb" />
        <autoload>
             <class name="myautoloadedclass" file="autoloadtest/autoloadtestclass.php" />
             <classPattern pattern="/^myalclass/" dir="autoloadtest/withpattern/" suffix=".cl.php" />
             <namespace name="jelixTests\foo" dir="autoloadtest" />
             <namespacePathMap name="jelixTests\bar" dir="autoloadtest/barns" suffix=".class.php" />
             <includePath dir="autoloadtest/incpath" suffix=".php" />
             <autoloader file="autoloadtest/myautoloader.php" />
        </autoload>
    </dependencies>
</module>
</code>


Ainsi le noeud important ici, est @@autoload@@.

Comme vous pouvez les lire à partir des noeuds enfants, il y a differentes façon de charger des classes :

  * une classe seule
  * un ensemble de classes correspondant à un pattern donné
  * un espace de nom
  * un ensemble de fichiers inclus depuis un chemin donné
  * un autoloader spécifique depuis lequel vous écrirez la partie du code qui utilisera [[http://php.net/spl_autoload_register|spl_autoload_register]] et ses amis
